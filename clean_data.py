import numpy as np
import pandas as pd
import os
import re
import gc

from sklearn.model_selection import train_test_split  
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.metrics import accuracy_score

# To run this file in background: nohup python -u clean_data.py &
# if need to kill for whatever reason: https://stackoverflow.com/questions/17385794/how-to-get-the-process-id-to-kill-a-nohup-process

# model imports
from sklearn.naive_bayes import GaussianNB

dtypes = {
    'MachineIdentifier':                                    'category',
    'ProductName':                                          'category',
    'EngineVersion':                                        'category',
    'AppVersion':                                           'category',
    'AvSigVersion':                                         'category',
    'IsBeta':                                               'int8',
    'RtpStateBitfield':                                     'float16',
    'IsSxsPassiveMode':                                     'int8',
    'DefaultBrowsersIdentifier':                            'float32',
    'AVProductStatesIdentifier':                            'float32',
    'AVProductsInstalled':                                  'float16',
    'AVProductsEnabled':                                    'float16',
    'HasTpm':                                               'int8',
    'CountryIdentifier':                                    'int16',
    'CityIdentifier':                                       'float32',
    'OrganizationIdentifier':                               'float16',
    'GeoNameIdentifier':                                    'float16',
    'LocaleEnglishNameIdentifier':                          'int16',
    'Platform':                                             'category',
    'Processor':                                            'category',
    'OsVer':                                                'category',
    'OsBuild':                                              'int16',
    'OsSuite':                                              'int16',
    'OsPlatformSubRelease':                                 'category',
    'OsBuildLab':                                           'category',
    'SkuEdition':                                           'category',
    'IsProtected':                                          'float16',
    'AutoSampleOptIn':                                      'int8',
    'PuaMode':                                              'category',
    'SMode':                                                'float16',
    'IeVerIdentifier':                                      'float16',
    'SmartScreen':                                          'category',
    'Firewall':                                             'float16',
    'UacLuaenable':                                         'float32',
    'UacLuaenable':                                         'float64', # was 'float32'
    'Census_MDC2FormFactor':                                'category',
    'Census_DeviceFamily':                                  'category',
    'Census_OEMNameIdentifier':                             'float32', # was 'float16'
    'Census_OEMModelIdentifier':                            'float32',
    'Census_ProcessorCoreCount':                            'float16',
    'Census_ProcessorManufacturerIdentifier':               'float16',
    'Census_ProcessorModelIdentifier':                      'float32', # was 'float16'
    'Census_ProcessorClass':                                'category',
    'Census_PrimaryDiskTotalCapacity':                      'float64', # was 'float32'
    'Census_PrimaryDiskTypeName':                           'category',
    'Census_SystemVolumeTotalCapacity':                     'float64', # was 'float32'
    'Census_HasOpticalDiskDrive':                           'int8',
    'Census_TotalPhysicalRAM':                              'float32',
    'Census_ChassisTypeName':                               'category',
    'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float32', # was 'float16'
    'Census_InternalPrimaryDisplayResolutionHorizontal':    'float32', # was 'float16'
    'Census_InternalPrimaryDisplayResolutionVertical':      'float32', # was 'float16'
    'Census_PowerPlatformRoleName':                         'category',
    'Census_InternalBatteryType':                           'category',
    'Census_InternalBatteryNumberOfCharges':                'float64', # was 'float32'
    'Census_OSVersion':                                     'category',
    'Census_OSArchitecture':                                'category',
    'Census_OSBranch':                                      'category',
    'Census_OSBuildNumber':                                 'int16',
    'Census_OSBuildRevision':                               'int32',
    'Census_OSEdition':                                     'category',
    'Census_OSSkuName':                                     'category',
    'Census_OSInstallTypeName':                             'category',
    'Census_OSInstallLanguageIdentifier':                   'float16',
    'Census_OSUILocaleIdentifier':                          'int16',
    'Census_OSWUAutoUpdateOptionsName':                     'category',
    'Census_IsPortableOperatingSystem':                     'int8',
    'Census_GenuineStateName':                              'category',
    'Census_ActivationChannel':                             'category',
    'Census_IsFlightingInternal':                           'float16',
    'Census_IsFlightsDisabled':                             'float16',
    'Census_FlightRing':                                    'category',
    'Census_ThresholdOptIn':                                'float16',
    'Census_FirmwareManufacturerIdentifier':                'float16',
    'Census_FirmwareVersionIdentifier':                     'float32',
    'Census_IsSecureBootEnabled':                           'int8',
    'Census_IsWIMBootEnabled':                              'float16',
    'Census_IsVirtualDevice':                               'float16',
    'Census_IsTouchEnabled':                                'int8',
    'Census_IsPenCapable':                                  'int8',
    'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
    'Wdft_IsGamer':                                         'float16',
    'Wdft_RegionIdentifier':                                'float16',
    'HasDetections':                                        'int8'
    }

def load(x):
    # only ignore the MachineIdentifier column
    # print(type(x))
    ignore = ['MachineIdentifier']
    if x in ignore: 
        return False
    else: 
        return True


def ohe(df, df2=None, column=None):

    cat_cols = df.select_dtypes(include='category').columns.tolist()
    uniques = {}
    col = cat_cols
    # print(type(df[col]))
    # print(type(pd.concat([df[col], df2[col]])))
    for col in cat_cols:
        uniques[col] = len(list(set(pd.concat([df[col], df2[col]]))))

    (rows_1, _) = df.shape
    # if df2:
    (rows_2, _) = df2.shape
    rows = rows_1 + rows_2

    potential_ohe = []
    for key, value in uniques.items():
        if value < 20:
            potential_ohe.append(key)
    # return potential_ohe, df, df2

    final_cats = []
    almost = []
    for col in potential_ohe:
    #     print(df.groupby(col).size())
        # print(col)
        ratio = sum(df.groupby(col).size())/rows_1

        # might be invalid
        try:
            ratio_2 = sum(df2.groupby(col).size())/rows_2
        except:
            continue
        

        if ratio > 0.9 or ratio_2 > 0.9:
            final_cats.append(col)
            if ratio < 1 or ratio_2 < 1:
                almost.append(col)

    for cat in almost:
        allowed_vals = df.groupby(cat).groups.keys()
        # map to value UNKNOWN
        df.loc[~df[cat].isin(allowed_vals), cat] = "UNKNOWN"
        df2.loc[~df2[cat].isin(allowed_vals), cat] = "UNKNOWN"

    remove_cols = ['PuaMode', 'Census_ProcessorClass', 'DefaultBrowsersIdentifier', 'Census_IsWIMBootEnabled', 'IsBeta', 'Census_IsFlightsDisabled', 'Census_IsFlightingInternal', 'AutoSampleOptIn', 'Census_ThresholdOptIn', 'SMode', 'Census_IsPortableOperatingSystem', 'Census_DeviceFamily', 'UacLuaenable', 'Census_IsVirtualDevice', 'ProductName', 'HasTpm', 'IsSxsPassiveMode', 'Firewall', 'AVProductsEnabled', 'RtpStateBitfield', 'OsVer', 'Platform', 'Census_IsPenCapable', 'OsSuite', 'IeVerIdentifier', 'Census_ProcessorManufacturerIdentifier', 'Census_InternalPrimaryDisplayResolutionVertical', 'Census_OSSkuName', 'Census_OSInstallLanguageIdentifier', 'OsBuild', 'Census_OSBuildNumber', 'Processor', 'SkuEdition']

    # remove_columns = list(set(potential_ohe) ^ set(final_cats))

    # get ones in union?

    remove_columns = list(set(remove_cols) - set(final_cats))

    df.drop(remove_columns, axis=1, inplace=True)
    df2.drop(remove_columns, axis=1, inplace=True)

    cols = []
    for col in list(df):
#     print(col)
        ratio = sum(df.groupby(col).size())/rows_1
        try:
            ratio_2 = sum(df2.groupby(col).size())/rows_2
        except:
            continue
        if ratio != 1:
            cols.append(col)
    # return cats, df

    # df = labelEncode(df)
    le = LabelEncoder()
    for col in cols:
        #         df.replace({col: {np.nan:0}}, inplace=True)
        df[col] = df[col].fillna(df[col].mode(), inplace=True)
        df[col] = le.fit_transform(df[col])

        df2[col] = df2[col].fillna(df2[col].mode(), inplace=True)
        df2[col] = le.fit_transform(df2[col])
    
    # return final_cats, df, df2
    # return final_cats, df
    # one hot encoding
    for cat in final_cats:
        dummies = pd.get_dummies(pd.concat([df[cat], df2[cat]]))
        df = pd.concat([df.drop(cat, axis=1), dummies[:rows_1]], axis=1)
        df2 = pd.concat([df2.drop(cat, axis=1), dummies[rows_1:]], axis=1)

        # df = pd.concat([df.drop(cat, axis=1), pd.get_dummies(df[cat])], axis=1)
        # df2 = pd.concat([df2.drop(cat, axis=1), pd.get_dummies(df2[cat])], axis=1)


    

    # null_vals = dict(df.select_dtypes(include=['category']).isnull().sum() > 0)
    # null_cats = [k for k,v in null_vals.items() if v == False]

    # df.drop(null_cats, axis=1, inplace=True)

    # null_vals = dict(df.select_dtypes(exclude=['category']).isnull().sum() > 0)
    # null_cats = [k for k,v in null_vals.items() if v == False]

    # df.drop(null_cats, axis=1, inplace=True)



    return df, df2

def labelEncode(df, encode=False):
    le = LabelEncoder()

    enc_columns = []
    # from https://www.kaggle.com/jiegeng94/everyone-do-this-at-the-beginning
    enc_columns += df.select_dtypes(include='category').columns.tolist()

    if not encode:
        for column in df:
            if pd.isnull(df[column]).sum() > 0:
                enc_columns.append(column)
                
    # maintain unique list
    enc_columns = list(set(enc_columns))

    for col in enc_columns:
    #         df.replace({col: {np.nan:0}}, inplace=True)
        df[col] = df[col].fillna(df[col].mode(), inplace=True)
        df[col] = le.fit_transform(df[col])

   
    return df

def read_data_two(path1, path2, debug=False):
    if debug:
        train = pd.read_csv(path1,dtype=dtypes,usecols=load,nrows=10000)
        test = pd.read_csv(path2,dtype=dtypes,usecols=load,nrows=10000)
    else:
        train = pd.read_csv(path1,dtype='dtypes',usecols=load)
        test = pd.read_csv(path2,dtype='dtypes',usecols=load)

    # *** WHY DO THIS?
    # Extract version from subversion
    train["AppVersion"] = train["AppVersion"].astype('category')
    train["AppVersion"] = train["AppVersion"].apply(lambda x:  (re.split(r'\.',x))[1])

    test["AppVersion"] = test["AppVersion"].astype('category')
    test["AppVersion"] = test["AppVersion"].apply(lambda x:  (re.split(r'\.',x))[1])

    # Extract version from EngineVersion
    train["EngineVersion"] = train["EngineVersion"].astype('category')
    train["EngineVersion"] = train["EngineVersion"].apply(lambda x:  (re.split(r'\.',x))[2])

    test["EngineVersion"] = test["EngineVersion"].astype('category')
    test["EngineVersion"] = test["EngineVersion"].apply(lambda x:  (re.split(r'\.',x))[2])
    # df["EngineVersion"].value_counts()

    # Extract version from AvSigVersion
    train["AvSigVersion"] = train["AvSigVersion"].astype('category')
    train["AvSigVersion"] = train["AvSigVersion"].apply(lambda x:  (re.split(r'\.',x))[1])

    test["AvSigVersion"] = test["AvSigVersion"].astype('category')
    test["AvSigVersion"] = test["AvSigVersion"].apply(lambda x:  (re.split(r'\.',x))[1])

    # this looks like all it's doing is correcting cases
    trans_dict = {
    'off': 'Off', '&#x02;': '2', '&#x01;': '1', 'on': 'On', 'requireadmin': 'RequireAdmin', 'OFF': 'Off', 
    'Promt': 'Prompt', 'requireAdmin': 'RequireAdmin', 'prompt': 'Prompt', 'warn': 'Warn', 
    '00000000': '0', '&#x03;': '3', np.nan: 'NoExist'
    }
    train.replace({'SmartScreen': trans_dict}, inplace=True)
    test.replace({'SmartScreen': trans_dict}, inplace=True)

    train.replace({'OrganizationIdentifier': {np.nan: 0}}, inplace=True)
    test.replace({'OrganizationIdentifier': {np.nan: 0}}, inplace=True)

    trans_dict = {
        '˙˙˙': 'unknown', 'unkn': 'unknown', np.nan: 'unknown'
    }
    train.replace({'Census_InternalBatteryType': trans_dict}, inplace=True)
    test.replace({'Census_InternalBatteryType': trans_dict}, inplace=True)

    train['SmartScreen'] = train.SmartScreen.astype('category')
    train['Census_InternalBatteryType'] = train.Census_InternalBatteryType.astype('category')

    test['SmartScreen'] = test.SmartScreen.astype('category')
    test['Census_InternalBatteryType'] = test.Census_InternalBatteryType.astype('category')

    encode = ['EngineVersion', 'AppVersion', 'AvSigVersion']

    for col in encode:
        train[col] = LabelEncoder().fit_transform(train[col])
        test[col] = LabelEncoder().fit_transform(test[col])

    # FOR TESTING PURPOSES, UNCOMMENT LATER
    # return train, test

    # return ohe(train, df2=test)

    train, test = ohe(train, df2=test)
    
    # drop anything that's invalid
    a = dict(train.isnull().sum() > 0)
    b = dict(test.isnull().sum() > 0)

    invalid = []
    for k, v in a.items():
        if isinstance(v, pd.Series):
            invalid.append(k)

    for k, v in a.items():
        if isinstance(v, pd.Series):
            invalid.append(k)

    # filter all duplicates out
    invalid = list(set(invalid))

    train.drop(invalid, axis=1, inplace=True)
    test.drop(invalid, axis=1, inplace=True)

    for col in list(train):
        if col == "HasDetections":
            continue
        train[col] = LabelEncoder().fit_transform(train[col])
        test[col] = LabelEncoder().fit_transform(test[col])


    return train, test

def read_data_one(path):

    df = pd.read_csv(path, dtype=dtypes)

    # # ***need to be able to explain why these columns are getting removed
    # remove_cols = ['MachineIdentifier','PuaMode', 'Census_ProcessorClass', 'DefaultBrowsersIdentifier', 'Census_IsWIMBootEnabled', 'IsBeta', 'Census_IsFlightsDisabled', 'Census_IsFlightingInternal', 'AutoSampleOptIn', 'Census_ThresholdOptIn', 'SMode', 'Census_IsPortableOperatingSystem', 'Census_DeviceFamily', 'UacLuaenable', 'Census_IsVirtualDevice', 'ProductName', 'HasTpm', 'IsSxsPassiveMode', 'Firewall', 'AVProductsEnabled', 'RtpStateBitfield', 'OsVer', 'Platform', 'Census_IsPenCapable', 'OsSuite', 'IeVerIdentifier', 'Census_ProcessorManufacturerIdentifier', 'Census_InternalPrimaryDisplayResolutionVertical', 'Census_OSSkuName', 'Census_OSInstallLanguageIdentifier', 'OsBuild', 'Census_OSBuildNumber', 'Processor', 'SkuEdition']

    # remove_cols = ['MachineIdentifier','PuaMode', 'Census_ProcessorClass', 'DefaultBrowsersIdentifier', 'Census_IsWIMBootEnabled', 'IsBeta', 'Census_IsFlightsDisabled', 'Census_IsFlightingInternal', 'AutoSampleOptIn', 'Census_ThresholdOptIn', 'SMode', 'Census_IsPortableOperatingSystem', 'Census_DeviceFamily', 'UacLuaenable', 'Census_IsVirtualDevice', 'ProductName', 'HasTpm', 'IsSxsPassiveMode', 'Firewall', 'AVProductsEnabled', 'RtpStateBitfield', 'OsVer', 'Platform', 'Census_IsPenCapable', 'OsSuite', 'IeVerIdentifier', 'Census_ProcessorManufacturerIdentifier', 'Census_InternalPrimaryDisplayResolutionVertical', 'Census_OSSkuName', 'Census_OSInstallLanguageIdentifier', 'OsBuild', 'Census_OSBuildNumber', 'Processor', 'SkuEdition']

    # df.drop(remove_cols, axis=1, inplace=True)

    # *** WHY DO THIS?
    # Extract version from subversion
    df["AppVersion"] = df["AppVersion"].astype('category')
    df["AppVersion"] = df["AppVersion"].apply(lambda x:  (re.split(r'\.',x))[1])
    # df["AppVersion"].value_counts()


    # Extract version from EngineVersion
    df["EngineVersion"] = df["EngineVersion"].astype('category')
    df["EngineVersion"] = df["EngineVersion"].apply(lambda x:  (re.split(r'\.',x))[2])
    # df["EngineVersion"].value_counts()


    # Extract version from AvSigVersion
    df["AvSigVersion"] = df["AvSigVersion"].astype('category')
    df["AvSigVersion"] = df["AvSigVersion"].apply(lambda x:  (re.split(r'\.',x))[1])

    # this looks like all it's doing is correcting cases
    trans_dict = {
    'off': 'Off', '&#x02;': '2', '&#x01;': '1', 'on': 'On', 'requireadmin': 'RequireAdmin', 'OFF': 'Off', 
    'Promt': 'Prompt', 'requireAdmin': 'RequireAdmin', 'prompt': 'Prompt', 'warn': 'Warn', 
    '00000000': '0', '&#x03;': '3', np.nan: 'NoExist'
    }
    df.replace({'SmartScreen': trans_dict}, inplace=True)

    df.replace({'OrganizationIdentifier': {np.nan: 0}}, inplace=True)

    trans_dict = {
        '˙˙˙': 'unknown', 'unkn': 'unknown', np.nan: 'unknown'
    }
    df.replace({'Census_InternalBatteryType': trans_dict}, inplace=True)

    df['SmartScreen'] = df.SmartScreen.astype('category')
    df['Census_InternalBatteryType'] = df.Census_InternalBatteryType.astype('category')

    encode = ['EngineVersion', 'AppVersion', 'AvSigVersion']

    for col in encode:
        df[col] = LabelEncoder().fit_transform(df[col])

    # FOR TESTING PURPOSES, UNCOMMENT LATER
    # return df

    df = ohe(df)
    a = dict(df.isnull().sum() > 0)

    invalid = []
    for k, v in a.items():
        if isinstance(a[k], pd.Series):
            invalid.append(k)

    df.drop(invalid, axis=1, inplace=True)

    for col in list(df):
        df[col] = LabelEncoder().fit_transform(df[col])


    return df

# uncomment if you want to run this as a script

# print("Starting run")
# df = read_data("input/train.csv")
# print("Data read")

# df[list(df)].to_csv("input/cleaned_train_0.csv")

# print("Starting run on testing")
# df = read_data("input/test.csv")
# print("Data read, exporting to cleaned_test_0.csv")
# df[list(df)].to_csv("input/cleaned_test_0.csv")

# print("Complete")


# uncomment for TESTING WITH MODEL
# print("Starting run")
# df = read_data("input/train_0_10000.csv")
# print("Data read")

# y = df['HasDetections'].values
# cols = list(df)
# cols.remove('HasDetections')
# X = df[cols]

# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2)

# print("Starting model")
# clf = GaussianNB()
# print("Fitting Gaussian model")
# clf.fit(X_train, y_train)
# print("Predicting on y_pred")
# y_pred = clf.predict(X_test)
# print("Accuracy score:", accuracy_score(y_test, y_pred))


